<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Binary Tree Game ‚Äì Simple Version</title>
<style>
body{
  font-family:'Segoe UI',Arial,sans-serif;
  background:#0f172a;
  color:#e5e7eb;
  margin:0;
  padding:20px;
  display:flex;
  gap:20px;
}

.panel{
  background:#020617;
  padding:20px;
  border-radius:12px;
  box-shadow:0 4px 6px rgba(0,0,0,0.3);
}

.left-panel{
  width:300px;
  display:flex;
  flex-direction:column;
  gap:16px;
}

.right-panel{
  flex:1;
  display:flex;
  flex-direction:column;
  align-items:center;
}

h3{
  margin:0 0 12px 0;
  color:#22c55e;
  font-size:18px;
}

input, select, button{
  width:100%;
  padding:10px;
  margin:4px 0;
  border:1px solid #334155;
  border-radius:6px;
  background:#1e293b;
  color:#e5e7eb;
  font-size:14px;
  cursor:pointer;
}

button:hover{
  background:#334155;
  border-color:#22c55e;
}

.stats{
  background:#1e293b;
  padding:12px;
  border-radius:8px;
  font-size:14px;
}

.stat-row{
  display:flex;
  justify-content:space-between;
  margin:8px 0;
  padding:8px;
  background:#0f172a;
  border-radius:6px;
}

.stat-label{
  color:#94a3b8;
}

.stat-value{
  color:#22c55e;
  font-weight:bold;
}

/* Tree Styles */
.tree{
  display:flex;
  justify-content:center;
  margin:40px;
}

.tree ul{
  display:flex;
  justify-content:center;
  position:relative;
  padding-top:30px;
  gap:10px;
  list-style:none;
}

.tree li{
  display:flex;
  flex-direction:column;
  align-items:center;
  position:relative;
}

/* Connector lines */
.tree li::before,
.tree li::after{
  content:"";
  position:absolute;
  top:-15px;
  width:0;
  height:15px;
  border-left:2px solid #64748b;
}

.tree li.active-branch::before,
.tree li.active-branch::after{
  border-color:#22c55e;
}

.tree li::before{left:calc(50% - 1px);}
.tree li::after{right:calc(50% - 1px);}
.tree li:only-child::before,
.tree li:only-child::after{display:none;}

.tree ul::before{
  content:"";
  position:absolute;
  top:0;
  left:50%;
  width:calc(100% - 24px);
  border-top:2px solid #64748b;
  transform:translateX(-50%);
}

.tree ul.active-branch::before{
  border-color:#22c55e;
}

/* Node */
.node{
  width:100px;
  min-height:100px;
  border-radius:12px;
  border:2px solid #64748b;
  background:linear-gradient(135deg, #020617 0%, #1e293b 100%);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  transition:all .3s ease;
  padding:10px;
  box-shadow:0 2px 8px rgba(0,0,0,0.3);
}

.node.active{
  background:linear-gradient(135deg, #16a34a 0%, #22c55e 100%);
  border-color:#22c55e;
  box-shadow:0 0 15px rgba(34,197,94,0.6);
}

.node.selected{
  border:3px solid #fbbf24;
  box-shadow:0 0 20px #fbbf24;
}

.node:hover{
  transform:scale(1.05);
}

.node-name{
  font-weight:bold;
  font-size:14px;
  margin-bottom:8px;
}

.node-info{
  font-size:11px;
  color:#e5e7eb;
  text-align:center;
  line-height:1.4;
}

.node-points{
  font-size:16px;
  font-weight:bold;
  color:#fbbf24;
  margin-top:4px;
}
.node-balanced {
  border: 3px solid #22c55e;
  box-shadow: 0 0 15px rgba(34, 197, 94, 0.6);
}
</style>
</head>
<body>

<div class="left-panel">
  <!-- Actions -->
  <div class="panel">
    <h3>üéÆ Actions</h3>
    <input id="treeName" placeholder="Enter tree name" />
    <select id="mode">
      <option value="single">Single Node</option>
      <option value="triple">Triple (L+R+Node)</option>
      <option value="vip">VIP (All Nodes)</option>
    </select>
    <button onclick="addTree()">üå≥ Transform To Tree</button>
    <button onclick="activateNode()">‚ö° Activate Node</button>
    <button onclick="resetTree()">üîÑ Reset Tree</button>
    <div style="margin-top:12px;padding:10px;background:#1e293b;border-radius:6px;">
      Selected: <strong id="selected">main</strong>
    </div>
  </div>

  <!-- Statistics -->
  <div class="panel">
    <h3>üìä Statistics</h3>
    <div class="stats">
      <div class="stat-row">
        <span class="stat-label">Total Points:</span>
        <span class="stat-value" id="totalPoints">0</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">Active Nodes:</span>
        <span class="stat-value" id="activeNodes">1</span>
      </div>
      <div class="stat-row">
        <span class="stat-label">Total Nodes:</span>
        <span class="stat-value" id="totalNodes">1</span>
      </div>
    </div>
  </div>

  <!-- Point Calculation Info -->
  <div class="panel">
    <h3>‚ÑπÔ∏è How Points Work</h3>
    <div style="font-size:12px;line-height:1.6;color:#94a3b8;">
      A node earns <strong style="color:#22c55e;">1 point</strong> when:
      <ul style="margin:8px 0;padding-left:20px;">
        <li>The node is <strong>active</strong></li>
        <li>It has <strong>both</strong> left and right children</li>
        <li><strong>Both</strong> children are active</li>
      </ul>
      Points accumulate from bottom to top!
    </div>
  </div>
</div>

<div class="right-panel panel">
  <h3>üå≤ Binary Tree</h3>
  <div id="tree" class="tree"></div>
</div>

<script>
/* ==============================================================
   DATA MODEL
   ============================================================== */
class TreeNode{
  constructor(name, parent=null){
    this.name = name;
    this.active = false;
    this.left = null;
    this.right = null;
    this.points = 0;
    this.parent = parent;
    this.activatedAt = null;
  }
}



let root = new TreeNode('main');
root.active = true;
let selectedNode = root;

/* ==============================================================
   HELPERS
   ============================================================== */
function traverse(node, cb){
  if(!node) return;
  cb(node);
  traverse(node.left, cb);
  traverse(node.right, cb);
}

function countNodes(node){
  if(!node) return 0;
  return 1 + countNodes(node.left) + countNodes(node.right);
}

function countActiveNodes(node){
  if(!node) return 0;
  const count = node.active ? 1 : 0;
  return count + countActiveNodes(node.left) + countActiveNodes(node.right);
}

function getTotalNodes(){
  let count = 0;
  traverse(root, () => count++);
  return count;
}

function getTotalPoints(){
  if(!root) return 0;
  // After recalculation, the root node holds the total score.
  // Summing all nodes would double-count the points.
  return root.points;
}

function getActiveNodesCount(){
  let count = 0;
  traverse(root, n => {if(n.active) count++;});
  return count;
}

/* ==============================================================
   POINT CALCULATION - FINAL VERSION
   Rules:
   1. INACTIVE nodes ALWAYS show 0 points (no accumulation)
   2. ACTIVE nodes earn 1 OWN point if both children are ACTIVE
   3. ACTIVE nodes accumulate points from their ACTIVE children only
   ============================================================== */
function recalculateAllPoints() {
  function dfs(node) {
    if (!node) return 0;

    // Recurse first (bottom-up)
    const leftPts = dfs(node.left);
    const rightPts = dfs(node.right);

    // If node is INACTIVE ‚Üí force 0 points and contribute nothing upward
    if (!node.active) {
      node.points = 0;
      return 0; // ‚¨ÖÔ∏è CRITICAL: block any child points from propagating up!
    }

    // Node is ACTIVE ‚Üí calculate own point
    let ownPoint = 0;
    if (node.left && node.right && node.left.active && node.right.active) {
      ownPoint = 1;
    }

    // Total = own + children's points (which are already filtered via DFS)
    node.points = ownPoint + leftPts + rightPts;
    return node.points;
  }

  dfs(root);
}



function activateNodeLogic(node){
  if(!node || node.active) return false;
  node.active = true;
  node.activatedAt = Date.now(); // ‚¨ÖÔ∏è ŸàŸÇÿ™ ÿßŸÑÿ™ŸÅÿπŸäŸÑ
  return true;
}


/* ==============================================================
   TREE BUILDING
   ============================================================== */
function buildChildren(node, name){
  node.left  = new TreeNode(name, node);
  node.right = new TreeNode(name, node);
  node.left.left   = new TreeNode(name, node.left);
  node.left.right  = new TreeNode(name, node.left);
  node.right.left  = new TreeNode(name, node.right);
  node.right.right = new TreeNode(name, node.right);
}

function activateByMode(tree, mode){
  if(mode === 'single'){
    activateNodeLogic(tree);
  }else if(mode === 'triple'){
    activateNodeLogic(tree.left);
    activateNodeLogic(tree.right);
    activateNodeLogic(tree);
  }else if(mode === 'vip'){
    const order = [];
    (function dfs(n){
      if(!n) return;
      dfs(n.left);
      dfs(n.right);
      order.push(n);
    })(tree);
    order.forEach(activateNodeLogic);
  }
  // NO recalculate here
}

/* ==============================================================
   UI CALLBACKS
   ============================================================== */
function addTree(){
  const name = document.getElementById('treeName').value.trim();
  const mode = document.getElementById('mode').value;
  if(!name){ 
    alert('Please enter a tree name'); 
    return; 
  }

  // Deactivate entire subtree
  traverse(selectedNode, n => {
    n.active = false;
    n.points = 0;
  });

  selectedNode.name = name;
  buildChildren(selectedNode, name);
  activateByMode(selectedNode, mode); // Now only sets .active = true, no recalc
  
  recalculateAllPoints(); // ‚Üê Only ONE recalc after all activations
  render();
  updateStats();
}

function activateNode(){
  const wasActivated = activateNodeLogic(selectedNode);
  if(wasActivated){
    recalculateAllPoints(); // Force recalculation
    render();
    updateStats();
  } else {
    alert('Node is already active!');
  }
}

function resetTree(){
  if(!confirm('Reset the entire tree?')) return;
  
  root = new TreeNode('main');
  root.active = true;
  selectedNode = root;
  
  document.getElementById('selected').innerText = root.name;
  render();
  updateStats();
}

/* ==============================================================
   RENDERING
   ============================================================== */
function renderNode(node){
  const li = document.createElement('li');
  if(node.active) li.classList.add('active-branch');

  const div = document.createElement('div');
  div.className = 'node' +
    (node.active ? ' active' : '') +
    (node === selectedNode ? ' selected' : '');

  // Count nodes in left and right subtrees
  const leftTotal = countNodes(node.left);
  const rightTotal = countNodes(node.right);
  const leftActive = countActiveNodes(node.left);
  const rightActive = countActiveNodes(node.right);

  div.innerHTML = `
    <div class="node-name">${node.name}</div>
    <div class="node-info">
      L: ${leftActive}/${leftTotal} active<br>
      R: ${rightActive}/${rightTotal} active
    </div>
    <div class="node-points">‚≠ê ${node.points} pts</div>
  `;

  div.onclick = e => {
    e.stopPropagation();
    selectedNode = node;
    document.getElementById('selected').innerText = node.name;
    render();
  };

  li.appendChild(div);

  if(node.left || node.right){
    const ul = document.createElement('ul');
    if(node.active) ul.classList.add('active-branch');
    if(node.left) ul.appendChild(renderNode(node.left));
    if(node.right) ul.appendChild(renderNode(node.right));
    li.appendChild(ul);
  }

  if (node.left && node.right && node.left.active && node.right.active) {
  div.classList.add('node-balanced');
} else {
  div.classList.remove('node-balanced');
}
  
  return li;
}

function render(){
  const container = document.getElementById('tree');
  container.innerHTML = '';
  const ul = document.createElement('ul');
  ul.appendChild(renderNode(root));
  container.appendChild(ul);
}

function updateStats(){
  document.getElementById('totalPoints').innerText = getTotalPoints();
  document.getElementById('activeNodes').innerText = getActiveNodesCount();
  document.getElementById('totalNodes').innerText = getTotalNodes();
}

/* ==============================================================
   INITIALIZATION
   ============================================================== */
render();
updateStats();
</script>
</body>
</html>